<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fabelwesen Mathe-Abwehr 3D - Typing of the Dead Style</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Arial', sans-serif;
            overflow: hidden;
            background: #000;
        }

        #gameCanvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 12px 25px;
            background: linear-gradient(to bottom, rgba(10, 5, 15, 0.9), rgba(20, 10, 25, 0.7));
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
            border-bottom: 2px solid #8B4513;
        }

        .stat-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 100px;
        }

        .stat {
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 10px currentColor;
        }

        .stat-label {
            font-size: 11px;
            color: #8B7355;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 3px;
        }

        #score { color: #FFD700; }
        #highscore { color: #CD853F; }
        #lives { color: #FF4444; }
        #chapter { color: #00CED1; }

        /* Input at bottom - compact */
        #inputContainer {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 10;
            background: linear-gradient(145deg, rgba(40, 25, 15, 0.95), rgba(25, 15, 8, 0.95));
            padding: 12px 18px;
            border-radius: 12px;
            box-shadow: 0 5px 25px rgba(0,0,0,0.6);
            border: 2px solid #8B4513;
        }

        #answerInput {
            width: 140px;
            padding: 12px;
            font-size: 24px;
            border: 2px solid #8B4513;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            background: rgba(255, 245, 220, 0.95);
            color: #3d2817;
            transition: all 0.2s;
        }

        #answerInput:focus {
            outline: none;
            border-color: #FFD700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        #submitButton {
            padding: 12px 20px;
            font-size: 20px;
            background: linear-gradient(145deg, #8B4513, #654321);
            border: 2px solid #DAA520;
            border-radius: 8px;
            color: #FFD700;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
        }

        #submitButton:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(218, 165, 32, 0.5);
        }

        /* Feedback */
        #feedback {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 70px;
            font-weight: bold;
            opacity: 0;
            pointer-events: none;
            z-index: 100;
            text-shadow: 4px 4px 8px rgba(0,0,0,0.8), 0 0 40px currentColor;
        }

        #feedback.correct {
            color: #7CFC00;
            animation: hitAnim 0.8s ease-out;
        }

        #feedback.wrong {
            color: #FF4444;
            animation: missAnim 0.5s ease-out;
        }

        @keyframes hitAnim {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.3); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1) translateY(-30px); }
        }

        @keyframes missAnim {
            0%, 100% { transform: translate(-50%, -50%); opacity: 1; }
            20% { transform: translate(-45%, -50%); }
            40% { transform: translate(-55%, -50%); }
            60% { transform: translate(-48%, -50%); }
            80% { transform: translate(-52%, -50%); opacity: 0.5; }
            100% { opacity: 0; }
        }

        /* Damage overlay */
        #damageOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
            opacity: 0;
            background: radial-gradient(ellipse at center, transparent 30%, rgba(180, 0, 0, 0.6) 100%);
        }

        #damageOverlay.active {
            animation: damageFlash 0.4s ease-out;
        }

        @keyframes damageFlash {
            0% { opacity: 0.9; }
            100% { opacity: 0; }
        }

        /* Screens */
        #startScreen, #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, rgba(25, 12, 35, 0.97) 0%, rgba(5, 2, 8, 0.99) 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            overflow-y: auto;
        }

        .screen-panel {
            background: linear-gradient(135deg, rgba(50, 30, 15, 0.95), rgba(30, 18, 8, 0.95));
            padding: 35px 45px;
            border-radius: 15px;
            border: 3px solid #8B4513;
            box-shadow: 0 15px 50px rgba(0,0,0,0.8), 0 0 60px rgba(139, 69, 19, 0.3);
            max-width: 800px;
            text-align: center;
            max-height: 90vh;
            overflow-y: auto;
        }

        .screen-panel h1 {
            font-size: 38px;
            margin-bottom: 15px;
            color: #FFD700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8), 0 0 30px rgba(255, 215, 0, 0.4);
        }

        .screen-panel p {
            font-size: 15px;
            margin-bottom: 15px;
            color: #c9a86c;
            line-height: 1.7;
        }

        .button {
            padding: 16px 40px;
            font-size: 20px;
            background: linear-gradient(145deg, #8B4513, #654321);
            border: 3px solid #DAA520;
            border-radius: 10px;
            color: #FFD700;
            cursor: pointer;
            box-shadow: 0 8px 25px rgba(139, 69, 19, 0.5);
            transition: all 0.3s;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .button:hover {
            transform: scale(1.05) translateY(-2px);
            box-shadow: 0 12px 35px rgba(218, 165, 32, 0.5);
        }

        .difficulty-selector {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            justify-content: center;
        }

        .difficulty-btn {
            padding: 10px 20px;
            font-size: 14px;
            border: 2px solid #8B4513;
            background: rgba(50, 30, 15, 0.8);
            color: #c9a86c;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .difficulty-btn:hover {
            background: rgba(70, 40, 20, 0.9);
        }

        .difficulty-btn.active {
            background: linear-gradient(145deg, #DAA520, #B8860B);
            border-color: #FFD700;
            color: #3d2817;
            font-weight: bold;
        }

        /* Number row selector */
        .row-selector {
            margin: 20px 0;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            border: 1px solid #8B4513;
        }

        .row-selector h3 {
            color: #FFD700;
            margin-bottom: 12px;
            font-size: 16px;
        }

        .row-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
        }

        .row-btn {
            width: 50px;
            height: 50px;
            border: 2px solid #8B4513;
            background: rgba(50, 30, 15, 0.8);
            color: #c9a86c;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.2s;
        }

        .row-btn:hover {
            background: rgba(70, 40, 20, 0.9);
            transform: scale(1.05);
        }

        .row-btn.active {
            background: linear-gradient(145deg, #4CAF50, #388E3C);
            border-color: #7CFC00;
            color: white;
            box-shadow: 0 0 10px rgba(124, 252, 0, 0.4);
        }

        .row-presets {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 12px;
        }

        .preset-btn {
            padding: 8px 16px;
            font-size: 12px;
            border: 1px solid #8B4513;
            background: rgba(80, 50, 25, 0.8);
            color: #c9a86c;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .preset-btn:hover {
            background: rgba(100, 60, 30, 0.9);
            color: #FFD700;
        }

        /* Combo display */
        #comboDisplay {
            position: absolute;
            top: 80px;
            right: 25px;
            font-size: 28px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 15px rgba(255, 215, 0, 0.5);
            opacity: 0;
            z-index: 10;
            transition: opacity 0.3s;
        }

        #comboDisplay.visible {
            opacity: 1;
        }

        /* Chapter announcement */
        #chapterAnnounce {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            color: #FFD700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.9), 0 0 30px rgba(255, 215, 0, 0.5);
            z-index: 30;
            opacity: 0;
            pointer-events: none;
        }

        #chapterAnnounce.visible {
            animation: chapterFade 3s ease-out;
        }

        @keyframes chapterFade {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            15% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            85% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }

        .heart {
            display: inline-block;
            margin: 0 2px;
            font-size: 20px;
        }

        .stats-row {
            display: flex;
            gap: 35px;
            justify-content: center;
            margin-bottom: 15px;
            font-size: 20px;
            color: #c9a86c;
        }

        .stats-row span {
            color: #FFD700;
        }

        /* Active creatures display at bottom */
        #activeCreatures {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 10;
        }

        .creature-card {
            background: linear-gradient(145deg, rgba(40, 25, 15, 0.9), rgba(25, 15, 8, 0.9));
            border: 2px solid #8B4513;
            border-radius: 10px;
            padding: 10px 15px;
            text-align: center;
            min-width: 100px;
            transition: all 0.3s;
        }

        .creature-card.targeted {
            border-color: #FFD700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            transform: scale(1.05);
        }

        .creature-card .name {
            font-size: 12px;
            color: #FF6B6B;
            margin-bottom: 5px;
        }

        .creature-card .question {
            font-size: 20px;
            color: #7CFC00;
            font-weight: bold;
        }

        .creature-card .timer {
            height: 4px;
            background: #333;
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
        }

        .creature-card .timer-fill {
            height: 100%;
            background: linear-gradient(90deg, #FF4444, #FFAA00, #7CFC00);
            transition: width 0.1s linear;
        }

        .creature-card .timer-fill.danger {
            background: #FF4444;
            animation: timerPulse 0.3s infinite;
        }

        @keyframes timerPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        #creatureCount {
            position: absolute;
            top: 80px;
            left: 25px;
            font-size: 16px;
            color: #c9a86c;
            z-index: 10;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
    </style>
</head>
<body>
    <div id="gameCanvas"></div>

    <div id="ui">
        <div class="stat-group">
            <span class="stat-label">Punkte</span>
            <span id="score" class="stat">0</span>
        </div>
        <div class="stat-group">
            <span class="stat-label">Highscore</span>
            <span id="highscore" class="stat">0</span>
        </div>
        <div class="stat-group">
            <span class="stat-label">Kapitel</span>
            <span id="chapter" class="stat">1</span>
        </div>
        <div class="stat-group">
            <span class="stat-label">Leben</span>
            <span id="lives" class="stat"></span>
        </div>
    </div>

    <div id="comboDisplay">COMBO x<span id="comboCount">0</span></div>
    <div id="creatureCount">Kreaturen: <span id="creatureNum">0</span></div>

    <div id="chapterAnnounce"></div>

    <div id="activeCreatures"></div>

    <div id="inputContainer">
        <input type="number" id="answerInput" placeholder="?" autocomplete="off">
        <button id="submitButton">FEUER</button>
    </div>

    <div id="feedback"></div>
    <div id="damageOverlay"></div>

    <div id="startScreen">
        <div class="screen-panel">
            <h1>Fabelwesen Abwehr</h1>
            <p>
                Bewege dich durch den dunklen Wald und besiege Fabelwesen!<br>
                <strong>Loese ihre Rechenaufgaben bevor die Zeit ablaeuft!</strong>
            </p>

            <div class="difficulty-selector">
                <button class="difficulty-btn active" data-difficulty="easy">Lehrling</button>
                <button class="difficulty-btn" data-difficulty="medium">Geselle</button>
                <button class="difficulty-btn" data-difficulty="hard">Meister</button>
            </div>

            <div class="row-selector">
                <h3>Zahlenreihen auswaehlen:</h3>
                <div class="row-buttons">
                    <button class="row-btn active" data-row="2">2</button>
                    <button class="row-btn active" data-row="3">3</button>
                    <button class="row-btn active" data-row="4">4</button>
                    <button class="row-btn active" data-row="5">5</button>
                    <button class="row-btn active" data-row="6">6</button>
                    <button class="row-btn active" data-row="7">7</button>
                    <button class="row-btn active" data-row="8">8</button>
                    <button class="row-btn active" data-row="9">9</button>
                    <button class="row-btn active" data-row="10">10</button>
                </div>
                <div class="row-presets">
                    <button class="preset-btn" onclick="selectRows([2,3,4,5])">Einfach (2-5)</button>
                    <button class="preset-btn" onclick="selectRows([6,7,8])">Mittel (6-8)</button>
                    <button class="preset-btn" onclick="selectRows([7,8,9])">Schwer (7-9)</button>
                    <button class="preset-btn" onclick="selectRows([2,3,4,5,6,7,8,9,10])">Alle</button>
                </div>
            </div>

            <button class="button" onclick="startGame()">Expedition starten!</button>
        </div>
    </div>

    <div id="gameOverScreen" style="display: none;">
        <div class="screen-panel">
            <h1>Expedition gescheitert!</h1>
            <p>Die Fabelwesen haben dich uebermannt...</p>
            <div class="stats-row">
                <div>Punkte: <span id="finalScore">0</span></div>
                <div>Kapitel: <span id="finalChapter">0</span></div>
            </div>
            <div class="stats-row">
                <div>Highscore: <span id="displayHighscore">0</span></div>
            </div>
            <div id="newHighscoreMessage" style="color: #FFD700; font-size: 22px; margin: 12px 0; display: none;">
                NEUER HIGHSCORE!
            </div>
            <button class="button" onclick="location.reload()">Nochmal!</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ==================== THREE.JS SETUP ====================
        let scene, camera, renderer;
        let activeCreatures = [];
        let particles = [];
        let environmentObjects = [];
        let pathPoints = [];
        let currentPathIndex = 0;
        let pathProgress = 0;

        // ==================== MATH PROBLEM POOL ====================
        let problemPool = [];
        let usedProblems = new Set();

        function initProblemPool() {
            problemPool = [];
            usedProblems.clear();

            const selectedRows = gameState.selectedRows;

            // Create all possible problems from selected rows
            for (const row of selectedRows) {
                for (let i = 2; i <= 10; i++) {
                    // Add both directions: row × i and i × row
                    const key1 = `${row}x${i}`;
                    const key2 = `${i}x${row}`;

                    if (!problemPool.some(p => p.key === key1)) {
                        problemPool.push({ num1: row, num2: i, key: key1 });
                    }
                    if (row !== i && !problemPool.some(p => p.key === key2)) {
                        problemPool.push({ num1: i, num2: row, key: key2 });
                    }
                }
            }

            // Shuffle the pool
            shuffleArray(problemPool);
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function getNextProblem() {
            // If pool is empty or all used, refill
            if (problemPool.length === 0 || usedProblems.size >= problemPool.length) {
                usedProblems.clear();
                shuffleArray(problemPool);
            }

            // Find unused problem
            for (const problem of problemPool) {
                if (!usedProblems.has(problem.key)) {
                    usedProblems.add(problem.key);
                    return { num1: problem.num1, num2: problem.num2 };
                }
            }

            // Fallback
            const idx = Math.floor(Math.random() * problemPool.length);
            return { num1: problemPool[idx].num1, num2: problemPool[idx].num2 };
        }

        // ==================== GAME STATE ====================
        let gameState = {
            score: 0,
            lives: 5,
            chapter: 1,
            isPlaying: false,
            difficulty: 'easy',
            combo: 0,
            highscore: parseInt(localStorage.getItem('mathGame3DHighscore') || '0'),
            cameraMoving: true,
            isInEncounter: false,
            totalDefeated: 0,
            chapterDefeated: 0,
            selectedRows: [2, 3, 4, 5, 6, 7, 8, 9, 10],
            maxActiveCreatures: 1,
            encounterScheduleTimer: null,
            nextEncounterDistance: 0,
            distanceTraveled: 0
        };

        const difficulties = {
            easy: { baseTime: 8000, minTime: 4000, encounterInterval: 25 },
            medium: { baseTime: 6000, minTime: 3000, encounterInterval: 20 },
            hard: { baseTime: 4500, minTime: 2500, encounterInterval: 15 }
        };

        // ==================== CREATURE DEFINITIONS ====================
        const creatureTypes = [
            { name: 'Werwolf', color: 0x4a3728, furColor: 0x5d4037, eyeColor: 0xffff00, points: 10, buildModel: buildWerewolf },
            { name: 'Greif', color: 0xdaa520, featherColor: 0xb8860b, eyeColor: 0xff6600, points: 15, buildModel: buildGriffin },
            { name: 'Gnom', color: 0x228b22, skinColor: 0xdeb887, eyeColor: 0x000000, points: 8, buildModel: buildGnome },
            { name: 'Drache', color: 0x8b0000, scaleColor: 0xb22222, eyeColor: 0xff0000, points: 25, buildModel: buildDragon },
            { name: 'Troll', color: 0x4a5568, skinColor: 0x6b7280, eyeColor: 0x90ee90, points: 20, buildModel: buildTroll },
            { name: 'Hexe', color: 0x4b0082, cloakColor: 0x2e0854, eyeColor: 0x00ff00, points: 18, buildModel: buildWitch }
        ];

        // ==================== ROW SELECTION ====================
        function selectRows(rows) {
            document.querySelectorAll('.row-btn').forEach(btn => {
                const row = parseInt(btn.dataset.row);
                if (rows.includes(row)) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            updateSelectedRows();
        }

        function updateSelectedRows() {
            gameState.selectedRows = [];
            document.querySelectorAll('.row-btn.active').forEach(btn => {
                gameState.selectedRows.push(parseInt(btn.dataset.row));
            });
            if (gameState.selectedRows.length === 0) {
                gameState.selectedRows = [2, 3, 4, 5, 6, 7, 8, 9, 10];
                document.querySelectorAll('.row-btn').forEach(btn => btn.classList.add('active'));
            }
        }

        // ==================== AUDIO ====================
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(type) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            switch(type) {
                case 'correct':
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(523, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(1047, audioContext.currentTime + 0.15);
                    gainNode.gain.setValueAtTime(0.25, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
                case 'wrong':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(180, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(60, audioContext.currentTime + 0.4);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.4);
                    break;
                case 'spawn':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(330, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.12, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.15);
                    break;
                case 'chapter':
                    oscillator.type = 'sine';
                    [523, 659, 784, 1047].forEach((freq, i) => {
                        oscillator.frequency.setValueAtTime(freq, audioContext.currentTime + i * 0.15);
                    });
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.7);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.7);
                    break;
                case 'timeWarning':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.08, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.08);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.08);
                    break;
            }
        }

        // ==================== 3D INITIALIZATION ====================
        function init3D() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050208);
            scene.fog = new THREE.FogExp2(0x0a0510, 0.02);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 1.7, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameCanvas').appendChild(renderer.domElement);

            // Lighting
            const ambient = new THREE.AmbientLight(0x1a1025, 0.5);
            scene.add(ambient);

            const moonLight = new THREE.DirectionalLight(0x6666aa, 0.4);
            moonLight.position.set(-50, 100, -50);
            moonLight.castShadow = true;
            scene.add(moonLight);

            createPath();
            createEnvironment();

            window.addEventListener('resize', onWindowResize);
        }

        function createPath() {
            pathPoints = [];
            let x = 0, z = 0, angle = 0;

            for (let i = 0; i < 150; i++) {
                pathPoints.push(new THREE.Vector3(x, 1.7, z));
                if (i > 0 && i % 8 === 0) {
                    angle += (Math.random() - 0.5) * 0.6;
                }
                x += Math.sin(angle) * 5;
                z -= Math.cos(angle) * 5;
            }
        }

        function createEnvironment() {
            // Ground
            const groundGeom = new THREE.PlaneGeometry(600, 600);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x1a0f05, roughness: 1 });
            const ground = new THREE.Mesh(groundGeom, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            pathPoints.forEach((point, i) => {
                if (i % 3 === 0) {
                    createTree(point.x - 6 - Math.random() * 4, point.z + (Math.random() - 0.5) * 4);
                    createTree(point.x + 6 + Math.random() * 4, point.z + (Math.random() - 0.5) * 4);
                }
                if (i % 5 === 0) {
                    createTorch(point.x - 3, point.z);
                    createTorch(point.x + 3, point.z);
                }
                if (i % 7 === 0 && Math.random() > 0.5) {
                    createGravestone(point.x + (Math.random() > 0.5 ? 4 : -4), point.z);
                }
            });

            // Moon
            const moonGeom = new THREE.SphereGeometry(8, 32, 32);
            const moonMat = new THREE.MeshBasicMaterial({ color: 0xffffee });
            const moon = new THREE.Mesh(moonGeom, moonMat);
            moon.position.set(-80, 80, -200);
            scene.add(moon);

            // Stars
            const starGeom = new THREE.BufferGeometry();
            const starPositions = [];
            for (let i = 0; i < 500; i++) {
                starPositions.push(
                    (Math.random() - 0.5) * 400,
                    50 + Math.random() * 100,
                    (Math.random() - 0.5) * 400 - 100
                );
            }
            starGeom.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
            const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 });
            scene.add(new THREE.Points(starGeom, starMat));
        }

        function createTree(x, z) {
            const group = new THREE.Group();
            const trunkGeom = new THREE.CylinderGeometry(0.3, 0.5, 6, 8);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x2d1b0e });
            const trunk = new THREE.Mesh(trunkGeom, trunkMat);
            trunk.position.y = 3;
            trunk.castShadow = true;
            group.add(trunk);

            for (let i = 0; i < 5; i++) {
                const branchGeom = new THREE.CylinderGeometry(0.03, 0.1, 1.5 + Math.random());
                const branch = new THREE.Mesh(branchGeom, trunkMat);
                branch.position.y = 3 + i * 0.9;
                branch.rotation.z = (Math.random() - 0.5) * 1.2;
                branch.rotation.y = Math.random() * Math.PI * 2;
                group.add(branch);
            }
            group.position.set(x, 0, z);
            scene.add(group);
        }

        function createTorch(x, z) {
            const group = new THREE.Group();
            const poleGeom = new THREE.CylinderGeometry(0.08, 0.12, 2.5, 6);
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x3d2817 });
            const pole = new THREE.Mesh(poleGeom, poleMat);
            pole.position.y = 1.25;
            group.add(pole);

            const fireLight = new THREE.PointLight(0xff6622, 1.5, 12);
            fireLight.position.y = 2.7;
            group.add(fireLight);

            const flameGeom = new THREE.ConeGeometry(0.1, 0.4, 8);
            const flameMat = new THREE.MeshBasicMaterial({ color: 0xff4400 });
            const flame = new THREE.Mesh(flameGeom, flameMat);
            flame.position.y = 2.7;
            group.add(flame);

            group.position.set(x, 0, z);
            group.userData.light = fireLight;
            environmentObjects.push(group);
            scene.add(group);
        }

        function createGravestone(x, z) {
            const height = 0.8 + Math.random() * 0.5;
            const geom = new THREE.BoxGeometry(0.6, height, 0.15);
            const mat = new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.9 });
            const stone = new THREE.Mesh(geom, mat);
            stone.position.set(x, height / 2, z);
            stone.rotation.y = (Math.random() - 0.5) * 0.4;
            stone.castShadow = true;
            scene.add(stone);
        }

        // ==================== CREATURE MODEL BUILDERS ====================
        function buildWerewolf(group, type) {
            const furMat = new THREE.MeshStandardMaterial({ color: type.furColor, roughness: 0.9 });
            const bodyMat = new THREE.MeshStandardMaterial({ color: type.color, roughness: 0.8 });

            const bodyGeom = new THREE.SphereGeometry(0.6, 16, 16);
            const body = new THREE.Mesh(bodyGeom, furMat);
            body.scale.set(1, 0.8, 1.2);
            body.position.y = 1;
            group.add(body);

            const headGeom = new THREE.SphereGeometry(0.35, 16, 16);
            const head = new THREE.Mesh(headGeom, furMat);
            head.position.set(0, 1.5, 0.4);
            group.add(head);

            const snoutGeom = new THREE.ConeGeometry(0.15, 0.4, 8);
            const snout = new THREE.Mesh(snoutGeom, bodyMat);
            snout.rotation.x = Math.PI / 2;
            snout.position.set(0, 1.45, 0.75);
            group.add(snout);

            [-0.2, 0.2].forEach(xOffset => {
                const earGeom = new THREE.ConeGeometry(0.1, 0.25, 4);
                const ear = new THREE.Mesh(earGeom, furMat);
                ear.position.set(xOffset, 1.85, 0.3);
                ear.rotation.x = -0.2;
                group.add(ear);
            });

            const eyeMat = new THREE.MeshBasicMaterial({ color: type.eyeColor });
            [-0.12, 0.12].forEach(xOffset => {
                const eyeGeom = new THREE.SphereGeometry(0.06, 8, 8);
                const eye = new THREE.Mesh(eyeGeom, eyeMat);
                eye.position.set(xOffset, 1.55, 0.65);
                group.add(eye);
            });

            [-0.5, 0.5].forEach(xOffset => {
                const armGeom = new THREE.CylinderGeometry(0.1, 0.08, 0.7, 8);
                const arm = new THREE.Mesh(armGeom, furMat);
                arm.position.set(xOffset, 0.8, 0.2);
                arm.rotation.z = xOffset > 0 ? -0.5 : 0.5;
                arm.rotation.x = 0.3;
                group.add(arm);
            });

            [-0.25, 0.25].forEach(xOffset => {
                const legGeom = new THREE.CylinderGeometry(0.12, 0.1, 0.8, 8);
                const leg = new THREE.Mesh(legGeom, furMat);
                leg.position.set(xOffset, 0.4, -0.1);
                group.add(leg);
            });
        }

        function buildGriffin(group, type) {
            const featherMat = new THREE.MeshStandardMaterial({ color: type.featherColor, roughness: 0.7 });
            const bodyMat = new THREE.MeshStandardMaterial({ color: type.color, metalness: 0.3, roughness: 0.5 });

            const bodyGeom = new THREE.SphereGeometry(0.7, 16, 16);
            const body = new THREE.Mesh(bodyGeom, bodyMat);
            body.scale.set(1, 0.7, 1.3);
            body.position.y = 0.9;
            group.add(body);

            const headGeom = new THREE.SphereGeometry(0.3, 16, 16);
            const head = new THREE.Mesh(headGeom, featherMat);
            head.position.set(0, 1.4, 0.6);
            group.add(head);

            const beakGeom = new THREE.ConeGeometry(0.1, 0.35, 4);
            const beakMat = new THREE.MeshStandardMaterial({ color: 0xff8c00 });
            const beak = new THREE.Mesh(beakGeom, beakMat);
            beak.rotation.x = Math.PI / 2;
            beak.position.set(0, 1.35, 0.9);
            group.add(beak);

            const eyeMat = new THREE.MeshBasicMaterial({ color: type.eyeColor });
            [-0.12, 0.12].forEach(xOffset => {
                const eyeGeom = new THREE.SphereGeometry(0.06, 8, 8);
                const eye = new THREE.Mesh(eyeGeom, eyeMat);
                eye.position.set(xOffset, 1.5, 0.8);
                group.add(eye);
            });

            [-1, 1].forEach(side => {
                const wingGeom = new THREE.BoxGeometry(1.2, 0.08, 0.6);
                const wing = new THREE.Mesh(wingGeom, featherMat);
                wing.position.set(side * 1.1, 1.1, 0);
                wing.rotation.z = side * 0.4;
                group.add(wing);
            });

            [-0.3, 0.3].forEach(xOffset => {
                const legGeom = new THREE.CylinderGeometry(0.08, 0.06, 0.6, 8);
                const leg = new THREE.Mesh(legGeom, bodyMat);
                leg.position.set(xOffset, 0.3, 0);
                group.add(leg);
            });
        }

        function buildGnome(group, type) {
            const skinMat = new THREE.MeshStandardMaterial({ color: type.skinColor, roughness: 0.8 });
            const clothMat = new THREE.MeshStandardMaterial({ color: type.color, roughness: 0.9 });

            const bodyGeom = new THREE.SphereGeometry(0.35, 16, 16);
            const body = new THREE.Mesh(bodyGeom, clothMat);
            body.scale.set(1, 1.2, 0.9);
            body.position.y = 0.5;
            group.add(body);

            const headGeom = new THREE.SphereGeometry(0.25, 16, 16);
            const head = new THREE.Mesh(headGeom, skinMat);
            head.position.y = 1;
            group.add(head);

            const noseGeom = new THREE.SphereGeometry(0.1, 8, 8);
            const nose = new THREE.Mesh(noseGeom, skinMat);
            nose.position.set(0, 0.95, 0.25);
            group.add(nose);

            const hatGeom = new THREE.ConeGeometry(0.25, 0.5, 8);
            const hatMat = new THREE.MeshStandardMaterial({ color: 0xcc0000 });
            const hat = new THREE.Mesh(hatGeom, hatMat);
            hat.position.y = 1.4;
            group.add(hat);

            const beardGeom = new THREE.ConeGeometry(0.2, 0.4, 8);
            const beardMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const beard = new THREE.Mesh(beardGeom, beardMat);
            beard.position.set(0, 0.65, 0.15);
            beard.rotation.x = Math.PI;
            group.add(beard);

            group.scale.setScalar(1.5);
        }

        function buildDragon(group, type) {
            const scaleMat = new THREE.MeshStandardMaterial({ color: type.scaleColor, roughness: 0.6, metalness: 0.2 });
            const bodyMat = new THREE.MeshStandardMaterial({ color: type.color, roughness: 0.5 });

            const bodyGeom = new THREE.SphereGeometry(0.8, 16, 16);
            const body = new THREE.Mesh(bodyGeom, scaleMat);
            body.scale.set(1, 0.7, 1.4);
            body.position.y = 1.2;
            group.add(body);

            const headGeom = new THREE.SphereGeometry(0.35, 16, 16);
            const head = new THREE.Mesh(headGeom, scaleMat);
            head.scale.set(1, 0.8, 1.3);
            head.position.set(0, 1.8, 0.7);
            group.add(head);

            [-0.2, 0.2].forEach(xOffset => {
                const hornGeom = new THREE.ConeGeometry(0.08, 0.4, 6);
                const hornMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
                const horn = new THREE.Mesh(hornGeom, hornMat);
                horn.position.set(xOffset, 2.15, 0.5);
                horn.rotation.x = -0.5;
                group.add(horn);
            });

            const eyeMat = new THREE.MeshBasicMaterial({ color: type.eyeColor });
            [-0.15, 0.15].forEach(xOffset => {
                const eyeGeom = new THREE.SphereGeometry(0.08, 8, 8);
                const eye = new THREE.Mesh(eyeGeom, eyeMat);
                eye.position.set(xOffset, 1.9, 0.95);
                group.add(eye);
            });

            [-1, 1].forEach(side => {
                const wingGeom = new THREE.BoxGeometry(1.5, 0.05, 0.8);
                const wingMat = new THREE.MeshStandardMaterial({ color: type.color, side: THREE.DoubleSide });
                const wing = new THREE.Mesh(wingGeom, wingMat);
                wing.position.set(side * 1.2, 1.4, 0);
                wing.rotation.z = side * 0.4;
                group.add(wing);
            });

            const fireLight = new THREE.PointLight(0xff4400, 2, 8);
            fireLight.position.set(0, 1.8, 1.2);
            group.add(fireLight);
        }

        function buildTroll(group, type) {
            const skinMat = new THREE.MeshStandardMaterial({ color: type.skinColor, roughness: 0.9 });

            const bodyGeom = new THREE.SphereGeometry(0.9, 16, 16);
            const body = new THREE.Mesh(bodyGeom, skinMat);
            body.scale.set(1, 1.1, 0.9);
            body.position.y = 1.3;
            group.add(body);

            const headGeom = new THREE.SphereGeometry(0.35, 16, 16);
            const head = new THREE.Mesh(headGeom, skinMat);
            head.position.y = 2.3;
            group.add(head);

            const noseGeom = new THREE.SphereGeometry(0.15, 8, 8);
            const nose = new THREE.Mesh(noseGeom, skinMat);
            nose.position.set(0, 2.2, 0.35);
            group.add(nose);

            const eyeMat = new THREE.MeshBasicMaterial({ color: type.eyeColor });
            [-0.12, 0.12].forEach(xOffset => {
                const eyeGeom = new THREE.SphereGeometry(0.06, 8, 8);
                const eye = new THREE.Mesh(eyeGeom, eyeMat);
                eye.position.set(xOffset, 2.35, 0.28);
                group.add(eye);
            });

            [-0.8, 0.8].forEach(xOffset => {
                const armGeom = new THREE.CylinderGeometry(0.2, 0.15, 1, 8);
                const arm = new THREE.Mesh(armGeom, skinMat);
                arm.position.set(xOffset, 1, 0.2);
                arm.rotation.z = xOffset > 0 ? -0.6 : 0.6;
                group.add(arm);
            });

            [-0.35, 0.35].forEach(xOffset => {
                const legGeom = new THREE.CylinderGeometry(0.2, 0.18, 0.6, 8);
                const leg = new THREE.Mesh(legGeom, skinMat);
                leg.position.set(xOffset, 0.3, 0);
                group.add(leg);
            });

            const clubGeom = new THREE.CylinderGeometry(0.08, 0.12, 1.2, 8);
            const clubMat = new THREE.MeshStandardMaterial({ color: 0x3d2817 });
            const club = new THREE.Mesh(clubGeom, clubMat);
            club.position.set(1.1, 0.8, 0.3);
            club.rotation.z = 0.3;
            group.add(club);
        }

        function buildWitch(group, type) {
            const cloakMat = new THREE.MeshStandardMaterial({ color: type.cloakColor, roughness: 0.9 });
            const skinMat = new THREE.MeshStandardMaterial({ color: 0x98fb98, roughness: 0.7 });

            const cloakGeom = new THREE.ConeGeometry(0.5, 1.4, 8);
            const cloak = new THREE.Mesh(cloakGeom, cloakMat);
            cloak.position.y = 0.7;
            group.add(cloak);

            const headGeom = new THREE.SphereGeometry(0.25, 16, 16);
            const head = new THREE.Mesh(headGeom, skinMat);
            head.position.y = 1.55;
            group.add(head);

            const noseGeom = new THREE.ConeGeometry(0.06, 0.2, 6);
            const nose = new THREE.Mesh(noseGeom, skinMat);
            nose.position.set(0, 1.5, 0.25);
            nose.rotation.x = Math.PI / 2 + 0.3;
            group.add(nose);

            const hatGeom = new THREE.ConeGeometry(0.35, 0.8, 8);
            const hatMat = new THREE.MeshStandardMaterial({ color: 0x1a0a2e });
            const hat = new THREE.Mesh(hatGeom, hatMat);
            hat.position.y = 2;
            group.add(hat);

            const brimGeom = new THREE.CylinderGeometry(0.45, 0.5, 0.05, 16);
            const brim = new THREE.Mesh(brimGeom, hatMat);
            brim.position.y = 1.65;
            group.add(brim);

            const eyeMat = new THREE.MeshBasicMaterial({ color: type.eyeColor });
            [-0.08, 0.08].forEach(xOffset => {
                const eyeGeom = new THREE.SphereGeometry(0.04, 8, 8);
                const eye = new THREE.Mesh(eyeGeom, eyeMat);
                eye.position.set(xOffset, 1.58, 0.2);
                group.add(eye);
            });

            const broomGeom = new THREE.CylinderGeometry(0.03, 0.03, 1.8, 8);
            const broomMat = new THREE.MeshStandardMaterial({ color: 0x4a3728 });
            const broom = new THREE.Mesh(broomGeom, broomMat);
            broom.position.set(0.5, 0.9, 0);
            broom.rotation.z = 0.2;
            group.add(broom);

            const auraLight = new THREE.PointLight(0x9932cc, 1, 5);
            auraLight.position.set(0, 1.2, 0.3);
            group.add(auraLight);
        }

        // ==================== CREATURE CLASS ====================
        class Creature {
            constructor(position, type, num1, num2) {
                this.type = type;
                this.num1 = num1;
                this.num2 = num2;
                this.answer = num1 * num2;
                this.question = `${num1} × ${num2}`;
                this.defeated = false;
                this.id = Math.random().toString(36).substr(2, 9);

                // Time management
                const diff = difficulties[gameState.difficulty];
                const timeReduction = Math.min(gameState.chapter * 150, diff.baseTime - diff.minTime);
                this.maxTime = diff.baseTime - timeReduction;
                this.timeLeft = this.maxTime;

                this.group = new THREE.Group();
                type.buildModel(this.group, type);

                this.group.position.copy(position);
                this.group.lookAt(camera.position);

                // Create 3D label above creature
                this.createLabel();

                scene.add(this.group);
                this.animPhase = Math.random() * Math.PI * 2;
            }

            createLabel() {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 96;

                // Background
                ctx.fillStyle = 'rgba(30, 15, 8, 0.9)';
                ctx.beginPath();
                ctx.roundRect(4, 4, 248, 88, 12);
                ctx.fill();

                // Border
                ctx.strokeStyle = '#DAA520';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.roundRect(4, 4, 248, 88, 12);
                ctx.stroke();

                // Question
                ctx.font = 'bold 42px Arial';
                ctx.fillStyle = '#7CFC00';
                ctx.textAlign = 'center';
                ctx.fillText(this.question + ' = ?', 128, 60);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
                this.label = new THREE.Sprite(spriteMat);
                this.label.scale.set(3, 1.2, 1);
                this.label.position.y = 3;
                this.group.add(this.label);
            }

            update(delta) {
                if (this.defeated) return false;

                this.animPhase += delta * 3;
                this.group.position.y = Math.sin(this.animPhase) * 0.05;

                // Make label face camera
                this.label.lookAt(camera.position);

                // Update time
                this.timeLeft -= delta * 1000;

                if (this.timeLeft <= 0) {
                    return true; // Time expired
                }

                return false;
            }

            defeat() {
                this.defeated = true;
                for (let i = 0; i < 25; i++) {
                    createExplosionParticle(this.group.position.clone(), this.type.color);
                }
                scene.remove(this.group);
            }

            remove() {
                scene.remove(this.group);
            }

            getTimePercent() {
                return (this.timeLeft / this.maxTime) * 100;
            }
        }

        function createExplosionParticle(position, color) {
            const geom = new THREE.SphereGeometry(0.1 + Math.random() * 0.1, 6, 6);
            const mat = new THREE.MeshBasicMaterial({ color: color });
            const particle = new THREE.Mesh(geom, mat);
            particle.position.copy(position);
            particle.position.y += 1;
            particle.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.4,
                Math.random() * 0.3 + 0.1,
                (Math.random() - 0.5) * 0.4
            );
            particle.life = 1;
            scene.add(particle);
            particles.push(particle);
        }

        // ==================== ENCOUNTER SYSTEM (RAIL-SHOOTER) ====================
        function scheduleNextEncounter() {
            const diff = difficulties[gameState.difficulty];
            // Random distance until next encounter (with some variation)
            const baseInterval = diff.encounterInterval - gameState.chapter * 1.5;
            gameState.nextEncounterDistance = gameState.distanceTraveled + Math.max(8, baseInterval + (Math.random() - 0.5) * 10);
        }

        function checkForEncounter() {
            if (!gameState.isPlaying || gameState.isInEncounter) return;

            if (gameState.distanceTraveled >= gameState.nextEncounterDistance) {
                triggerEncounter();
            }
        }

        function triggerEncounter() {
            gameState.isInEncounter = true;
            gameState.cameraMoving = false;

            playSound('spawn');

            // Determine how many creatures to spawn
            const numCreatures = Math.min(gameState.maxActiveCreatures, 1 + Math.floor(gameState.chapter / 3));

            // Get camera look direction for positioning
            const lookDir = new THREE.Vector3();
            camera.getWorldDirection(lookDir);

            // Spawn creatures in front of camera
            for (let i = 0; i < numCreatures; i++) {
                const problem = getNextProblem();
                const typeIndex = Math.floor(Math.random() * Math.min(creatureTypes.length, 2 + Math.floor(gameState.chapter / 2)));
                const type = creatureTypes[typeIndex];

                // Position: in front, spread out horizontally
                const offset = (i - (numCreatures - 1) / 2) * 4;
                const spawnPos = camera.position.clone();
                spawnPos.add(lookDir.clone().multiplyScalar(8 + Math.random() * 2));

                // Offset to the side
                const right = new THREE.Vector3();
                right.crossVectors(lookDir, new THREE.Vector3(0, 1, 0)).normalize();
                spawnPos.add(right.clone().multiplyScalar(offset));
                spawnPos.y = 0;

                const creature = new Creature(spawnPos, type, problem.num1, problem.num2);
                activeCreatures.push(creature);
            }

            updateCreatureDisplay();
            updateCreatureCount();

            // Animate camera to look at center of creatures
            if (activeCreatures.length > 0) {
                const centerPos = new THREE.Vector3();
                activeCreatures.forEach(c => centerPos.add(c.group.position));
                centerPos.divideScalar(activeCreatures.length);
                centerPos.y = 1.5;
                animateCameraLook(centerPos);
            }
        }

        function animateCameraLook(target) {
            const startQuat = camera.quaternion.clone();
            const tempCam = camera.clone();
            tempCam.lookAt(target);
            const endQuat = tempCam.quaternion.clone();

            let progress = 0;
            const animateLook = () => {
                if (!gameState.isPlaying) return;

                progress += 0.05;
                if (progress >= 1) {
                    camera.quaternion.copy(endQuat);
                    return;
                }
                camera.quaternion.slerpQuaternions(startQuat, endQuat, easeOutCubic(progress));
                requestAnimationFrame(animateLook);
            };
            animateLook();
        }

        function easeOutCubic(t) {
            return 1 - Math.pow(1 - t, 3);
        }

        function endEncounter() {
            gameState.isInEncounter = false;
            gameState.cameraMoving = true;
            scheduleNextEncounter();

            // Brief pause before camera moves again
            setTimeout(() => {
                if (gameState.isPlaying && !gameState.isInEncounter) {
                    // Smoothly look back to path direction
                    if (pathPoints.length > 0) {
                        const lookAheadIndex = Math.min(currentPathIndex + 5, pathPoints.length - 1);
                        const lookTarget = pathPoints[lookAheadIndex].clone();
                        lookTarget.y = 1.5;
                        animateCameraLook(lookTarget);
                    }
                }
            }, 500);
        }

        function updateCreatureDisplay() {
            const container = document.getElementById('activeCreatures');
            container.innerHTML = activeCreatures.map(c => `
                <div class="creature-card" data-id="${c.id}">
                    <div class="name">${c.type.name}</div>
                    <div class="question">${c.question}</div>
                    <div class="timer">
                        <div class="timer-fill ${c.getTimePercent() < 30 ? 'danger' : ''}"
                             style="width: ${c.getTimePercent()}%"></div>
                    </div>
                </div>
            `).join('');
        }

        function updateCreatureCount() {
            document.getElementById('creatureNum').textContent = activeCreatures.length;
        }

        // ==================== GAME LOGIC ====================
        function processAnswer(answer) {
            if (!gameState.isPlaying || activeCreatures.length === 0) return;

            // Find creature with matching answer (closest first by time)
            let matchIndex = -1;
            let lowestTime = Infinity;

            for (let i = 0; i < activeCreatures.length; i++) {
                const c = activeCreatures[i];
                if (c.answer === answer && c.timeLeft < lowestTime) {
                    matchIndex = i;
                    lowestTime = c.timeLeft;
                }
            }

            if (matchIndex >= 0) {
                const creature = activeCreatures[matchIndex];
                creature.defeat();

                // Score
                const timeBonus = Math.floor((creature.timeLeft / creature.maxTime) * 15);
                gameState.combo++;
                const comboBonus = Math.floor(gameState.combo / 3) * 5;
                const points = creature.type.points * gameState.chapter + timeBonus + comboBonus;
                gameState.score += points;

                gameState.totalDefeated++;
                gameState.chapterDefeated++;

                activeCreatures.splice(matchIndex, 1);

                updateUI();
                updateCombo();
                updateCreatureDisplay();
                updateCreatureCount();
                showFeedback('TREFFER!', 'correct');
                playSound('correct');

                // Check if encounter is over (all creatures defeated)
                if (activeCreatures.length === 0 && gameState.isInEncounter) {
                    endEncounter();
                }

                // Chapter advancement
                if (gameState.chapterDefeated >= 8 + gameState.chapter * 3) {
                    advanceChapter();
                }
            } else {
                showFeedback('DANEBEN!', 'wrong');
                playSound('wrong');
                gameState.combo = 0;
                updateCombo();
            }
        }

        function creatureExpired(creature) {
            creature.remove();
            const idx = activeCreatures.indexOf(creature);
            if (idx >= 0) activeCreatures.splice(idx, 1);

            loseLife();
            showFeedback('ZEIT!', 'wrong');
            gameState.combo = 0;
            updateCombo();
            updateCreatureDisplay();
            updateCreatureCount();

            // Check if encounter is over (all creatures gone)
            if (activeCreatures.length === 0 && gameState.isInEncounter) {
                endEncounter();
            }
        }

        function advanceChapter() {
            gameState.chapter++;
            gameState.chapterDefeated = 0;

            // Increase max active creatures
            gameState.maxActiveCreatures = Math.min(1 + Math.floor(gameState.chapter / 2), 4);

            playSound('chapter');
            announceChapter();
            updateUI();
        }

        function loseLife() {
            gameState.lives--;
            const overlay = document.getElementById('damageOverlay');
            overlay.classList.add('active');
            setTimeout(() => overlay.classList.remove('active'), 400);
            updateUI();

            if (gameState.lives <= 0) {
                gameOver();
            }
        }

        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('chapter').textContent = gameState.chapter;
            document.getElementById('highscore').textContent = gameState.highscore;
            document.getElementById('lives').innerHTML = Array(gameState.lives).fill('<span class="heart">❤</span>').join('');
        }

        function updateCombo() {
            const comboEl = document.getElementById('comboDisplay');
            const countEl = document.getElementById('comboCount');
            if (gameState.combo >= 3) {
                countEl.textContent = gameState.combo;
                comboEl.classList.add('visible');
            } else {
                comboEl.classList.remove('visible');
            }
        }

        function showFeedback(text, type) {
            const feedback = document.getElementById('feedback');
            feedback.textContent = text;
            feedback.className = type;
            setTimeout(() => feedback.className = '', 800);
        }

        function announceChapter() {
            const announce = document.getElementById('chapterAnnounce');
            announce.textContent = `Kapitel ${gameState.chapter} - Bis zu ${gameState.maxActiveCreatures} Kreaturen!`;
            announce.classList.add('visible');
            setTimeout(() => announce.classList.remove('visible'), 3000);
        }

        function handleSubmit() {
            const input = document.getElementById('answerInput');
            const value = parseInt(input.value);
            if (!isNaN(value)) {
                processAnswer(value);
                input.value = '';
            }
        }

        function startGame() {
            updateSelectedRows();
            initProblemPool();
            init3D();

            document.getElementById('startScreen').style.display = 'none';

            gameState.isPlaying = true;
            gameState.score = 0;
            gameState.lives = 5;
            gameState.chapter = 1;
            gameState.combo = 0;
            gameState.totalDefeated = 0;
            gameState.chapterDefeated = 0;
            gameState.cameraMoving = true;
            gameState.isInEncounter = false;
            gameState.maxActiveCreatures = 1;
            gameState.distanceTraveled = 0;
            currentPathIndex = 0;
            pathProgress = 0;
            activeCreatures = [];

            updateUI();
            updateCombo();
            announceChapter();

            document.getElementById('answerInput').focus();

            // Schedule first encounter
            scheduleNextEncounter();

            lastTime = performance.now();
            animate();
        }

        function gameOver() {
            gameState.isPlaying = false;

            if (gameState.score > gameState.highscore) {
                gameState.highscore = gameState.score;
                localStorage.setItem('mathGame3DHighscore', gameState.score);
                document.getElementById('newHighscoreMessage').style.display = 'block';
            }

            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('finalChapter').textContent = gameState.chapter;
            document.getElementById('displayHighscore').textContent = gameState.highscore;
            document.getElementById('gameOverScreen').style.display = 'flex';
        }

        // ==================== ANIMATION LOOP ====================
        let lastTime = 0;

        function animate(currentTime = 0) {
            if (!gameState.isPlaying) return;

            requestAnimationFrame(animate);

            const delta = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            // Camera movement (Rail-shooter style)
            if (gameState.cameraMoving && pathPoints.length > 0 && !gameState.isInEncounter) {
                const moveSpeed = delta * 0.3;
                pathProgress += moveSpeed;

                // Track distance for encounter triggering
                gameState.distanceTraveled += moveSpeed * 5;

                if (pathProgress >= 1) {
                    pathProgress = 0;
                    currentPathIndex++;
                    if (currentPathIndex >= pathPoints.length - 1) currentPathIndex = 0;
                }

                const currentPoint = pathPoints[currentPathIndex];
                const nextPoint = pathPoints[Math.min(currentPathIndex + 1, pathPoints.length - 1)];
                camera.position.lerpVectors(currentPoint, nextPoint, pathProgress);

                // Only auto-look ahead when not in encounter transition
                if (!gameState.isInEncounter) {
                    const lookAheadIndex = Math.min(currentPathIndex + 3, pathPoints.length - 1);
                    const lookTarget = pathPoints[lookAheadIndex].clone();
                    lookTarget.y = 1.5;

                    const tempCam = camera.clone();
                    tempCam.lookAt(lookTarget);
                    camera.quaternion.slerp(tempCam.quaternion, 0.03);
                }

                // Check for encounter
                checkForEncounter();
            }

            // Update creatures
            for (let i = activeCreatures.length - 1; i >= 0; i--) {
                const creature = activeCreatures[i];
                const expired = creature.update(delta);
                if (expired) {
                    creatureExpired(creature);
                }
            }

            // Update creature display (timers)
            if (activeCreatures.length > 0) {
                updateCreatureDisplay();
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.velocity);
                p.velocity.y -= 0.015;
                p.life -= 0.02;
                p.scale.setScalar(p.life);
                if (p.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }

            // Flicker torches
            environmentObjects.forEach(obj => {
                if (obj.userData.light) {
                    obj.userData.light.intensity = 1.3 + Math.sin(currentTime * 0.01 + obj.position.x) * 0.4;
                }
            });

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ==================== EVENT LISTENERS ====================
        document.querySelectorAll('.difficulty-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                gameState.difficulty = btn.dataset.difficulty;
            });
        });

        document.querySelectorAll('.row-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                btn.classList.toggle('active');
                updateSelectedRows();
            });
        });

        document.getElementById('submitButton').addEventListener('click', handleSubmit);
        document.getElementById('answerInput').addEventListener('keypress', e => {
            if (e.key === 'Enter') handleSubmit();
        });

        document.getElementById('highscore').textContent = gameState.highscore;
    </script>
</body>
</html>
