<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fabelwesen Mathe-Abwehr 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Arial', sans-serif;
            overflow: hidden;
            background: #000;
        }

        #gameCanvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 15px 25px;
            background: linear-gradient(to bottom, rgba(20, 10, 30, 0.95), rgba(40, 20, 60, 0.85));
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            z-index: 10;
            border-bottom: 3px solid #8B4513;
        }

        .stat-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 120px;
        }

        .stat {
            font-size: 28px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 10px currentColor;
        }

        .stat-label {
            font-size: 12px;
            color: #c9a86c;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 5px;
        }

        #score { color: #FFD700; }
        #highscore { color: #FFA500; }
        #lives { color: #FF4444; }
        #level { color: #7CFC00; }
        #wave { color: #00CED1; }

        #inputContainer {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 10;
            background: linear-gradient(145deg, rgba(60, 40, 20, 0.95), rgba(40, 25, 15, 0.95));
            padding: 20px 25px;
            border-radius: 15px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.1);
            border: 3px solid #8B4513;
        }

        #answerInput {
            width: 200px;
            padding: 18px;
            font-size: 28px;
            border: 3px solid #8B4513;
            border-radius: 10px;
            text-align: center;
            font-family: 'Segoe UI', sans-serif;
            font-weight: bold;
            background: rgba(255, 245, 220, 0.95);
            color: #3d2817;
            transition: all 0.3s;
        }

        #answerInput:focus {
            outline: none;
            border-color: #DAA520;
            box-shadow: 0 0 20px rgba(218, 165, 32, 0.5), inset 0 0 10px rgba(218, 165, 32, 0.2);
            transform: scale(1.02);
        }

        #submitButton {
            padding: 18px 35px;
            font-size: 32px;
            background: linear-gradient(145deg, #8B4513, #654321);
            border: 2px solid #DAA520;
            border-radius: 10px;
            color: #FFD700;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(139, 69, 19, 0.5);
        }

        #submitButton:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 25px rgba(218, 165, 32, 0.6);
            background: linear-gradient(145deg, #A0522D, #8B4513);
        }

        #feedback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 100px;
            font-weight: bold;
            opacity: 0;
            pointer-events: none;
            z-index: 100;
            text-shadow: 4px 4px 8px rgba(0,0,0,0.8), 0 0 30px currentColor;
        }

        #feedback.correct {
            color: #7CFC00;
            animation: feedbackAnim 1.2s;
        }

        #feedback.wrong {
            color: #FF4444;
            animation: shakeAnim 0.6s;
        }

        @keyframes feedbackAnim {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.3) rotate(-10deg); }
            30% { opacity: 1; transform: translate(-50%, -50%) scale(1.5) rotate(5deg); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1) rotate(0deg) translateY(-50px); }
        }

        @keyframes shakeAnim {
            0%, 100% { transform: translate(-50%, -50%); opacity: 1; }
            10%, 30%, 50%, 70%, 90% { transform: translate(-55%, -50%); }
            20%, 40%, 60%, 80% { transform: translate(-45%, -50%); }
        }

        #startScreen, #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, rgba(30, 15, 45, 0.95) 0%, rgba(10, 5, 15, 0.98) 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
        }

        .screen-panel {
            background: linear-gradient(135deg, rgba(60, 40, 20, 0.9), rgba(40, 25, 15, 0.95));
            padding: 50px 60px;
            border-radius: 20px;
            border: 4px solid #8B4513;
            box-shadow: 0 15px 50px rgba(0,0,0,0.7), inset 0 1px 0 rgba(255,255,255,0.1), 0 0 60px rgba(139, 69, 19, 0.3);
            max-width: 750px;
            text-align: center;
        }

        .screen-panel h1 {
            font-size: 52px;
            margin-bottom: 25px;
            color: #FFD700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8), 0 0 30px rgba(255, 215, 0, 0.5);
            animation: titleGlow 3s ease-in-out infinite;
        }

        @keyframes titleGlow {
            0%, 100% { text-shadow: 3px 3px 6px rgba(0,0,0,0.8), 0 0 30px rgba(255, 215, 0, 0.5); }
            50% { text-shadow: 3px 3px 6px rgba(0,0,0,0.8), 0 0 50px rgba(255, 215, 0, 0.8); }
        }

        .screen-panel p {
            font-size: 17px;
            margin-bottom: 25px;
            color: #c9a86c;
            line-height: 1.9;
        }

        .creature-preview {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 25px 0;
        }

        .creature-icon {
            font-size: 50px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            animation: creatureFloat 2s ease-in-out infinite;
        }

        .creature-icon:nth-child(2) { animation-delay: 0.3s; }
        .creature-icon:nth-child(3) { animation-delay: 0.6s; }
        .creature-icon:nth-child(4) { animation-delay: 0.9s; }

        @keyframes creatureFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .button {
            padding: 20px 50px;
            font-size: 26px;
            background: linear-gradient(145deg, #8B4513, #654321);
            border: 3px solid #DAA520;
            border-radius: 12px;
            color: #FFD700;
            cursor: pointer;
            box-shadow: 0 8px 25px rgba(139, 69, 19, 0.5);
            transition: all 0.3s;
            font-family: 'Segoe UI', sans-serif;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .button:hover {
            transform: scale(1.08) translateY(-3px);
            box-shadow: 0 12px 35px rgba(218, 165, 32, 0.6);
            background: linear-gradient(145deg, #A0522D, #8B4513);
        }

        .difficulty-selector {
            display: flex;
            gap: 15px;
            margin: 25px 0;
            justify-content: center;
            flex-wrap: wrap;
        }

        .difficulty-btn {
            padding: 14px 28px;
            font-size: 16px;
            border: 2px solid #8B4513;
            background: rgba(60, 40, 20, 0.8);
            color: #c9a86c;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .difficulty-btn:hover {
            background: rgba(80, 50, 25, 0.9);
            transform: scale(1.05);
        }

        .difficulty-btn.active {
            background: linear-gradient(145deg, #DAA520, #B8860B);
            border-color: #FFD700;
            color: #3d2817;
            font-weight: bold;
            box-shadow: 0 0 15px rgba(218, 165, 32, 0.5);
        }

        .combo {
            position: absolute;
            top: 100px;
            right: 30px;
            font-size: 32px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8), 0 0 20px rgba(255, 215, 0, 0.5);
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 10;
        }

        .combo.visible {
            opacity: 1;
            animation: comboPulse 0.5s ease-out;
        }

        @keyframes comboPulse {
            0% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        .stats-row {
            display: flex;
            gap: 40px;
            justify-content: center;
            margin-bottom: 20px;
            font-size: 22px;
            color: #c9a86c;
        }

        .stats-row span {
            color: #FFD700;
        }

        #damageOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
            opacity: 0;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(255, 0, 0, 0.4) 100%);
            transition: opacity 0.1s;
        }

        #damageOverlay.active {
            opacity: 1;
            animation: damageFlash 0.3s ease-out;
        }

        @keyframes damageFlash {
            0% { opacity: 0.8; }
            100% { opacity: 0; }
        }

        .heart {
            display: inline-block;
            margin: 0 3px;
            animation: heartBeat 1.5s ease-in-out infinite;
        }

        @keyframes heartBeat {
            0%, 100% { transform: scale(1); }
            10% { transform: scale(1.15); }
            20% { transform: scale(1); }
        }

        #targetInfo {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(145deg, rgba(60, 40, 20, 0.95), rgba(40, 25, 15, 0.95));
            padding: 15px 30px;
            border-radius: 12px;
            border: 2px solid #8B4513;
            color: #FFD700;
            font-size: 24px;
            font-weight: bold;
            z-index: 10;
            display: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #targetInfo .creature-name {
            color: #FF6B6B;
            margin-right: 15px;
        }

        #targetInfo .question {
            color: #7CFC00;
        }

        #creatureCount {
            position: absolute;
            top: 100px;
            left: 30px;
            font-size: 18px;
            color: #c9a86c;
            z-index: 10;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
    </style>
</head>
<body>
    <div id="gameCanvas"></div>

    <div id="ui">
        <div class="stat-group">
            <span class="stat-label">Punkte</span>
            <span id="score" class="stat">0</span>
        </div>
        <div class="stat-group">
            <span class="stat-label">Highscore</span>
            <span id="highscore" class="stat">0</span>
        </div>
        <div class="stat-group">
            <span class="stat-label">Level</span>
            <span id="level" class="stat">1</span>
        </div>
        <div class="stat-group">
            <span class="stat-label">Welle</span>
            <span id="wave" class="stat">1</span>
        </div>
        <div class="stat-group">
            <span class="stat-label">Leben</span>
            <span id="lives" class="stat"></span>
        </div>
    </div>

    <div id="combo" class="combo">COMBO x<span id="comboCount">0</span></div>
    <div id="creatureCount">Kreaturen: <span id="creatureNum">0</span></div>

    <div id="targetInfo">
        <span class="creature-name" id="targetName">Werwolf</span>
        <span class="question" id="targetQuestion">3 x 4 = ?</span>
    </div>

    <div id="inputContainer">
        <input type="number" id="answerInput" placeholder="Antwort..." autocomplete="off">
        <button id="submitButton">FEUER</button>
    </div>

    <div id="feedback"></div>
    <div id="damageOverlay"></div>

    <div id="startScreen">
        <div class="screen-panel">
            <h1>Fabelwesen Mathe-Abwehr</h1>
            <div class="creature-preview">
                <span class="creature-icon">Werwolf</span>
                <span class="creature-icon">Greif</span>
                <span class="creature-icon">Gnom</span>
                <span class="creature-icon">Drache</span>
            </div>
            <p>
                Fabelwesen nahen aus der Dunkelheit!<br>
                Besiege sie mit der Macht der Mathematik!<br><br>
                <strong>Tippe die richtige Antwort</strong> zur Multiplikationsaufgabe<br>
                und druecke ENTER oder den FEUER-Button!<br><br>
                Lass keine Kreatur zu nah kommen - oder du verlierst ein Leben!
            </p>

            <div class="difficulty-selector">
                <button class="difficulty-btn active" data-difficulty="easy">Lehrling (2-5)</button>
                <button class="difficulty-btn" data-difficulty="medium">Geselle (2-8)</button>
                <button class="difficulty-btn" data-difficulty="hard">Meister (2-10)</button>
            </div>

            <button class="button" onclick="startGame()">Kampf beginnen!</button>
        </div>
    </div>

    <div id="gameOverScreen" style="display: none;">
        <div class="screen-panel">
            <h1>Niederlage!</h1>
            <p>Die Fabelwesen haben dich uebermannt...</p>
            <div class="stats-row">
                <div>Punkte: <span id="finalScore">0</span></div>
                <div>Level: <span id="finalLevel">0</span></div>
            </div>
            <div class="stats-row">
                <div>Highscore: <span id="displayHighscore">0</span></div>
            </div>
            <div id="newHighscoreMessage" style="color: #FFD700; font-size: 24px; margin: 15px 0; display: none;">
                NEUER HIGHSCORE!
            </div>
            <button class="button" onclick="location.reload()">Erneut kaempfen!</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Three.js Setup
        let scene, camera, renderer;
        let creatures = [];
        let particles = [];
        let ground, fog;
        let ambientLight, directionalLight, pointLights = [];

        // Game State
        let gameState = {
            score: 0,
            lives: 5,
            level: 1,
            wave: 1,
            isPlaying: false,
            difficulty: 'easy',
            combo: 0,
            highscore: parseInt(localStorage.getItem('mathGame3DHighscore') || '0'),
            creaturesDefeated: 0,
            waveCreatures: 0,
            spawnTimer: 0
        };

        const difficulties = {
            easy: { maxNumber: 5, speed: 0.015, spawnRate: 3500 },
            medium: { maxNumber: 8, speed: 0.02, spawnRate: 2800 },
            hard: { maxNumber: 10, speed: 0.025, spawnRate: 2200 }
        };

        // Creature Types
        const creatureTypes = [
            { name: 'Werwolf', color: 0x5D4037, emissive: 0x3E2723, scale: 1.0, points: 10 },
            { name: 'Greif', color: 0xFFD700, emissive: 0xB8860B, scale: 1.2, points: 15 },
            { name: 'Gnom', color: 0x2E7D32, emissive: 0x1B5E20, scale: 0.7, points: 8 },
            { name: 'Drache', color: 0xC62828, emissive: 0x8B0000, scale: 1.5, points: 25 },
            { name: 'Troll', color: 0x455A64, emissive: 0x263238, scale: 1.8, points: 20 },
            { name: 'Fee', color: 0xE91E63, emissive: 0xAD1457, scale: 0.5, points: 12 }
        ];

        // Audio Context
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(type) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            switch(type) {
                case 'correct':
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(880, audioContext.currentTime + 0.1);
                    oscillator.frequency.exponentialRampToValueAtTime(1320, audioContext.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.4);
                    break;
                case 'wrong':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(80, audioContext.currentTime + 0.3);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
                case 'damage':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.5);
                    gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                    break;
                case 'levelup':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(523, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(659, audioContext.currentTime + 0.1);
                    oscillator.frequency.setValueAtTime(784, audioContext.currentTime + 0.2);
                    oscillator.frequency.setValueAtTime(1047, audioContext.currentTime + 0.3);
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                    break;
            }
        }

        function init3D() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0510);
            scene.fog = new THREE.FogExp2(0x1a0a25, 0.015);

            // Camera (First Person View)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 0);
            camera.lookAt(0, 1.5, -50);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameCanvas').appendChild(renderer.domElement);

            // Lighting
            ambientLight = new THREE.AmbientLight(0x2a1a3a, 0.4);
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0x8866aa, 0.6);
            directionalLight.position.set(10, 20, -10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Moonlight
            const moonLight = new THREE.PointLight(0x6666ff, 0.8, 100);
            moonLight.position.set(-20, 30, -40);
            scene.add(moonLight);

            // Torch lights along the path
            for (let i = 0; i < 6; i++) {
                const torchLight = new THREE.PointLight(0xff6600, 0.8, 15);
                torchLight.position.set((i % 2 === 0 ? -8 : 8), 3, -i * 20 - 10);
                scene.add(torchLight);
                pointLights.push(torchLight);

                // Torch holder
                const torchGeom = new THREE.CylinderGeometry(0.1, 0.15, 2, 8);
                const torchMat = new THREE.MeshStandardMaterial({ color: 0x4a3728 });
                const torch = new THREE.Mesh(torchGeom, torchMat);
                torch.position.copy(torchLight.position);
                torch.position.y -= 1;
                scene.add(torch);
            }

            // Ground - Dark forest path
            const groundGeom = new THREE.PlaneGeometry(30, 200);
            const groundMat = new THREE.MeshStandardMaterial({
                color: 0x2a1a0a,
                roughness: 0.9,
                metalness: 0.1
            });
            ground = new THREE.Mesh(groundGeom, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.z = -80;
            ground.receiveShadow = true;
            scene.add(ground);

            // Path stones
            for (let i = 0; i < 40; i++) {
                const stoneGeom = new THREE.BoxGeometry(
                    Math.random() * 1.5 + 0.5,
                    0.1,
                    Math.random() * 1.5 + 0.5
                );
                const stoneMat = new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(0.08, 0.2, 0.15 + Math.random() * 0.1)
                });
                const stone = new THREE.Mesh(stoneGeom, stoneMat);
                stone.position.set(
                    (Math.random() - 0.5) * 10,
                    0.05,
                    -Math.random() * 150 - 5
                );
                stone.rotation.y = Math.random() * Math.PI;
                stone.receiveShadow = true;
                scene.add(stone);
            }

            // Trees on the sides
            for (let i = 0; i < 30; i++) {
                createTree(-12 - Math.random() * 10, -i * 6 - 5);
                createTree(12 + Math.random() * 10, -i * 6 - 5);
            }

            // Gravestones
            for (let i = 0; i < 15; i++) {
                createGravestone(
                    (Math.random() > 0.5 ? 1 : -1) * (8 + Math.random() * 5),
                    -i * 12 - 10
                );
            }

            // Moon
            const moonGeom = new THREE.SphereGeometry(5, 32, 32);
            const moonMat = new THREE.MeshBasicMaterial({ color: 0xffffcc });
            const moon = new THREE.Mesh(moonGeom, moonMat);
            moon.position.set(-30, 50, -150);
            scene.add(moon);

            window.addEventListener('resize', onWindowResize);
        }

        function createTree(x, z) {
            const trunkGeom = new THREE.CylinderGeometry(0.3, 0.5, 4, 8);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x2d1b0e });
            const trunk = new THREE.Mesh(trunkGeom, trunkMat);
            trunk.position.set(x, 2, z);
            trunk.castShadow = true;
            scene.add(trunk);

            // Dead tree - no leaves, just branches
            for (let i = 0; i < 4; i++) {
                const branchGeom = new THREE.CylinderGeometry(0.05, 0.15, 2 + Math.random());
                const branch = new THREE.Mesh(branchGeom, trunkMat);
                branch.position.set(x, 3 + i * 0.5, z);
                branch.rotation.z = (Math.random() - 0.5) * 1.5;
                branch.rotation.y = Math.random() * Math.PI * 2;
                scene.add(branch);
            }
        }

        function createGravestone(x, z) {
            const height = 1 + Math.random() * 0.5;
            const geom = new THREE.BoxGeometry(0.8, height, 0.2);
            const mat = new THREE.MeshStandardMaterial({
                color: 0x4a4a4a,
                roughness: 0.9
            });
            const stone = new THREE.Mesh(geom, mat);
            stone.position.set(x, height / 2, z);
            stone.rotation.y = (Math.random() - 0.5) * 0.3;
            stone.castShadow = true;
            scene.add(stone);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Creature Class
        class Creature {
            constructor(level, difficulty) {
                const diffConfig = difficulties[difficulty];
                const typeIndex = Math.floor(Math.random() * Math.min(creatureTypes.length, 2 + Math.floor(level / 2)));
                this.type = creatureTypes[typeIndex];

                // Math problem
                const maxNum = Math.min(diffConfig.maxNumber, 2 + Math.floor(level / 2));
                this.num1 = Math.floor(Math.random() * (maxNum - 1)) + 2;
                this.num2 = Math.floor(Math.random() * (maxNum - 1)) + 2;
                this.answer = this.num1 * this.num2;
                this.question = `${this.num1} x ${this.num2}`;

                // Speed increases with level
                this.speed = diffConfig.speed * (1 + level * 0.05);

                // Create 3D model
                this.createModel();

                // Position
                this.mesh.position.set(
                    (Math.random() - 0.5) * 12,
                    this.type.scale,
                    -80 - Math.random() * 30
                );

                this.defeated = false;
                this.wobblePhase = Math.random() * Math.PI * 2;

                // Question label (3D text sprite)
                this.createLabel();
            }

            createModel() {
                const group = new THREE.Group();

                // Body
                const bodyGeom = new THREE.SphereGeometry(1, 16, 16);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: this.type.color,
                    emissive: this.type.emissive,
                    emissiveIntensity: 0.3,
                    roughness: 0.7
                });
                const body = new THREE.Mesh(bodyGeom, bodyMat);
                body.scale.setScalar(this.type.scale);
                body.castShadow = true;
                group.add(body);

                // Eyes (glowing)
                const eyeGeom = new THREE.SphereGeometry(0.15, 8, 8);
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });

                const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
                leftEye.position.set(-0.3, 0.3, 0.8);
                leftEye.scale.setScalar(this.type.scale);
                group.add(leftEye);

                const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
                rightEye.position.set(0.3, 0.3, 0.8);
                rightEye.scale.setScalar(this.type.scale);
                group.add(rightEye);

                // Point light for eyes
                const eyeLight = new THREE.PointLight(0xff0000, 0.5, 5);
                eyeLight.position.set(0, 0.3, 0.9);
                group.add(eyeLight);

                // Type-specific features
                this.addCreatureFeatures(group);

                this.mesh = group;
                scene.add(this.mesh);
            }

            addCreatureFeatures(group) {
                const mat = new THREE.MeshStandardMaterial({
                    color: this.type.color,
                    emissive: this.type.emissive,
                    emissiveIntensity: 0.2
                });

                switch(this.type.name) {
                    case 'Werwolf':
                        // Ears
                        const earGeom = new THREE.ConeGeometry(0.2, 0.5, 4);
                        const leftEar = new THREE.Mesh(earGeom, mat);
                        leftEar.position.set(-0.5, 0.9, 0);
                        leftEar.scale.setScalar(this.type.scale);
                        group.add(leftEar);
                        const rightEar = new THREE.Mesh(earGeom, mat);
                        rightEar.position.set(0.5, 0.9, 0);
                        rightEar.scale.setScalar(this.type.scale);
                        group.add(rightEar);
                        // Snout
                        const snoutGeom = new THREE.ConeGeometry(0.3, 0.6, 8);
                        const snout = new THREE.Mesh(snoutGeom, mat);
                        snout.rotation.x = Math.PI / 2;
                        snout.position.set(0, 0, 1);
                        snout.scale.setScalar(this.type.scale);
                        group.add(snout);
                        break;

                    case 'Greif':
                        // Wings
                        const wingGeom = new THREE.BoxGeometry(1.5, 0.1, 0.8);
                        const leftWing = new THREE.Mesh(wingGeom, mat);
                        leftWing.position.set(-1.2, 0.5, 0);
                        leftWing.rotation.z = 0.3;
                        leftWing.scale.setScalar(this.type.scale);
                        group.add(leftWing);
                        const rightWing = new THREE.Mesh(wingGeom, mat);
                        rightWing.position.set(1.2, 0.5, 0);
                        rightWing.rotation.z = -0.3;
                        rightWing.scale.setScalar(this.type.scale);
                        group.add(rightWing);
                        // Beak
                        const beakGeom = new THREE.ConeGeometry(0.2, 0.5, 4);
                        const beak = new THREE.Mesh(beakGeom, new THREE.MeshStandardMaterial({ color: 0xFFA000 }));
                        beak.rotation.x = Math.PI / 2;
                        beak.position.set(0, 0, 1);
                        beak.scale.setScalar(this.type.scale);
                        group.add(beak);
                        break;

                    case 'Gnom':
                        // Hat
                        const hatGeom = new THREE.ConeGeometry(0.4, 0.8, 8);
                        const hat = new THREE.Mesh(hatGeom, new THREE.MeshStandardMaterial({ color: 0xff0000 }));
                        hat.position.set(0, 1, 0);
                        hat.scale.setScalar(this.type.scale);
                        group.add(hat);
                        // Beard
                        const beardGeom = new THREE.ConeGeometry(0.3, 0.5, 8);
                        const beard = new THREE.Mesh(beardGeom, new THREE.MeshStandardMaterial({ color: 0xcccccc }));
                        beard.position.set(0, -0.3, 0.7);
                        beard.rotation.x = Math.PI;
                        beard.scale.setScalar(this.type.scale);
                        group.add(beard);
                        break;

                    case 'Drache':
                        // Horns
                        const hornGeom = new THREE.ConeGeometry(0.15, 0.6, 6);
                        const leftHorn = new THREE.Mesh(hornGeom, new THREE.MeshStandardMaterial({ color: 0x333333 }));
                        leftHorn.position.set(-0.4, 0.9, 0);
                        leftHorn.rotation.z = -0.3;
                        leftHorn.scale.setScalar(this.type.scale);
                        group.add(leftHorn);
                        const rightHorn = new THREE.Mesh(hornGeom, new THREE.MeshStandardMaterial({ color: 0x333333 }));
                        rightHorn.position.set(0.4, 0.9, 0);
                        rightHorn.rotation.z = 0.3;
                        rightHorn.scale.setScalar(this.type.scale);
                        group.add(rightHorn);
                        // Wings
                        const dragonWingGeom = new THREE.BoxGeometry(2, 0.1, 1);
                        const dragonWingMat = new THREE.MeshStandardMaterial({ color: 0x8B0000 });
                        const dLeftWing = new THREE.Mesh(dragonWingGeom, dragonWingMat);
                        dLeftWing.position.set(-1.5, 0.3, -0.3);
                        dLeftWing.rotation.z = 0.4;
                        dLeftWing.scale.setScalar(this.type.scale);
                        group.add(dLeftWing);
                        const dRightWing = new THREE.Mesh(dragonWingGeom, dragonWingMat);
                        dRightWing.position.set(1.5, 0.3, -0.3);
                        dRightWing.rotation.z = -0.4;
                        dRightWing.scale.setScalar(this.type.scale);
                        group.add(dRightWing);
                        // Fire glow
                        const fireLight = new THREE.PointLight(0xff4400, 1, 8);
                        fireLight.position.set(0, 0, 1.5);
                        group.add(fireLight);
                        break;

                    case 'Troll':
                        // Club
                        const clubGeom = new THREE.CylinderGeometry(0.15, 0.25, 1.5, 8);
                        const club = new THREE.Mesh(clubGeom, new THREE.MeshStandardMaterial({ color: 0x4a3728 }));
                        club.position.set(1.2, -0.3, 0.5);
                        club.rotation.z = 0.5;
                        club.scale.setScalar(this.type.scale);
                        group.add(club);
                        // Nose
                        const noseGeom = new THREE.SphereGeometry(0.25, 8, 8);
                        const nose = new THREE.Mesh(noseGeom, mat);
                        nose.position.set(0, 0, 0.9);
                        nose.scale.setScalar(this.type.scale);
                        group.add(nose);
                        break;

                    case 'Fee':
                        // Wings (glowing)
                        const feeWingMat = new THREE.MeshBasicMaterial({
                            color: 0xff99ff,
                            transparent: true,
                            opacity: 0.7
                        });
                        const feeWingGeom = new THREE.CircleGeometry(0.6, 16);
                        const fLeftWing = new THREE.Mesh(feeWingGeom, feeWingMat);
                        fLeftWing.position.set(-0.6, 0.2, -0.2);
                        fLeftWing.rotation.y = -0.5;
                        fLeftWing.scale.setScalar(this.type.scale);
                        group.add(fLeftWing);
                        const fRightWing = new THREE.Mesh(feeWingGeom, feeWingMat);
                        fRightWing.position.set(0.6, 0.2, -0.2);
                        fRightWing.rotation.y = 0.5;
                        fRightWing.scale.setScalar(this.type.scale);
                        group.add(fRightWing);
                        // Sparkle light
                        const sparkleLight = new THREE.PointLight(0xff66ff, 1, 6);
                        sparkleLight.position.set(0, 0, 0);
                        group.add(sparkleLight);
                        break;
                }
            }

            createLabel() {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 128;

                // Background
                context.fillStyle = 'rgba(40, 25, 15, 0.9)';
                context.roundRect(0, 0, 256, 128, 15);
                context.fill();

                // Border
                context.strokeStyle = '#DAA520';
                context.lineWidth = 4;
                context.roundRect(0, 0, 256, 128, 15);
                context.stroke();

                // Creature name
                context.font = 'bold 24px Arial';
                context.fillStyle = '#FF6B6B';
                context.textAlign = 'center';
                context.fillText(this.type.name, 128, 40);

                // Question
                context.font = 'bold 36px Arial';
                context.fillStyle = '#7CFC00';
                context.fillText(this.question + ' = ?', 128, 90);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMat = new THREE.SpriteMaterial({ map: texture });
                this.label = new THREE.Sprite(spriteMat);
                this.label.scale.set(4, 2, 1);
                scene.add(this.label);
            }

            update() {
                if (this.defeated) return;

                // Move toward player
                this.mesh.position.z += this.speed;

                // Wobble animation
                this.wobblePhase += 0.05;
                this.mesh.rotation.y = Math.sin(this.wobblePhase) * 0.2;
                this.mesh.position.y = this.type.scale + Math.sin(this.wobblePhase * 2) * 0.1;

                // Update label position
                this.label.position.copy(this.mesh.position);
                this.label.position.y += this.type.scale + 1.5;

                // Check if reached player
                if (this.mesh.position.z > -2) {
                    return true; // Creature reached player
                }
                return false;
            }

            defeat() {
                this.defeated = true;

                // Create explosion particles
                const pos = this.mesh.position.clone();
                for (let i = 0; i < 20; i++) {
                    createParticle(pos, this.type.color);
                }

                // Remove from scene
                scene.remove(this.mesh);
                scene.remove(this.label);
            }

            destroy() {
                scene.remove(this.mesh);
                scene.remove(this.label);
            }
        }

        // Particle system
        function createParticle(position, color) {
            const geom = new THREE.SphereGeometry(0.15, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: color });
            const particle = new THREE.Mesh(geom, mat);
            particle.position.copy(position);
            particle.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.3,
                Math.random() * 0.3,
                (Math.random() - 0.5) * 0.3
            );
            particle.life = 1;
            scene.add(particle);
            particles.push(particle);
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.velocity);
                p.velocity.y -= 0.01; // Gravity
                p.life -= 0.02;
                p.scale.setScalar(p.life);

                if (p.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }
        }

        // Game Functions
        function spawnCreature() {
            if (!gameState.isPlaying) return;

            const creature = new Creature(gameState.level, gameState.difficulty);
            creatures.push(creature);
            gameState.waveCreatures++;
            updateCreatureCount();
        }

        function updateCreatureCount() {
            document.getElementById('creatureNum').textContent = creatures.length;
        }

        function processAnswer(answer) {
            if (!gameState.isPlaying || creatures.length === 0) return;

            let found = false;
            // Find the closest creature with matching answer
            let closestIndex = -1;
            let closestZ = -Infinity;

            for (let i = 0; i < creatures.length; i++) {
                const c = creatures[i];
                if (!c.defeated && c.answer === answer && c.mesh.position.z > closestZ) {
                    closestZ = c.mesh.position.z;
                    closestIndex = i;
                }
            }

            if (closestIndex >= 0) {
                const creature = creatures[closestIndex];
                creature.defeat();

                gameState.combo++;
                const comboBonus = Math.floor(gameState.combo / 3);
                const points = creature.type.points * gameState.level + comboBonus * 5;
                gameState.score += points;
                gameState.creaturesDefeated++;

                // Show target info briefly
                showTargetInfo(creature.type.name, creature.question);

                updateUI();
                updateCombo();
                showFeedback('TREFFER!', 'correct');
                playSound('correct');

                creatures.splice(closestIndex, 1);
                updateCreatureCount();

                // Level up check
                if (gameState.creaturesDefeated > 0 && gameState.creaturesDefeated % 10 === 0) {
                    gameState.level++;
                    gameState.wave++;
                    playSound('levelup');
                    updateUI();
                }

                found = true;
            }

            if (!found) {
                showFeedback('DANEBEN!', 'wrong');
                playSound('wrong');
                gameState.combo = 0;
                updateCombo();
            }
        }

        function showTargetInfo(name, question) {
            const info = document.getElementById('targetInfo');
            document.getElementById('targetName').textContent = name;
            document.getElementById('targetQuestion').textContent = question + ' = ' + eval(question.replace('x', '*'));
            info.style.display = 'block';
            setTimeout(() => {
                info.style.display = 'none';
            }, 1500);
        }

        function loseLife() {
            gameState.lives--;
            gameState.combo = 0;
            updateCombo();
            playSound('damage');

            // Damage overlay
            const overlay = document.getElementById('damageOverlay');
            overlay.classList.add('active');
            setTimeout(() => overlay.classList.remove('active'), 300);

            updateUI();

            if (gameState.lives <= 0) {
                gameOver();
            }
        }

        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('level').textContent = gameState.level;
            document.getElementById('wave').textContent = gameState.wave;
            document.getElementById('highscore').textContent = gameState.highscore;

            const livesEl = document.getElementById('lives');
            livesEl.innerHTML = '';
            for (let i = 0; i < gameState.lives; i++) {
                livesEl.innerHTML += '<span class="heart">&#10084;</span>';
            }
        }

        function updateCombo() {
            const comboEl = document.getElementById('combo');
            const countEl = document.getElementById('comboCount');

            if (gameState.combo >= 3) {
                countEl.textContent = gameState.combo;
                comboEl.classList.add('visible');
            } else {
                comboEl.classList.remove('visible');
            }
        }

        function showFeedback(text, type) {
            const feedback = document.getElementById('feedback');
            feedback.textContent = text;
            feedback.className = type;
            setTimeout(() => {
                feedback.className = '';
            }, 1000);
        }

        function handleSubmit() {
            const input = document.getElementById('answerInput');
            const value = parseInt(input.value);

            if (!isNaN(value)) {
                processAnswer(value);
                input.value = '';
                input.focus();
            }
        }

        function startGame() {
            init3D();

            document.getElementById('startScreen').style.display = 'none';
            gameState.isPlaying = true;
            gameState.score = 0;
            gameState.lives = 5;
            gameState.level = 1;
            gameState.wave = 1;
            gameState.combo = 0;
            gameState.creaturesDefeated = 0;
            gameState.waveCreatures = 0;
            creatures = [];
            particles = [];

            updateUI();
            updateCombo();
            updateCreatureCount();

            document.getElementById('answerInput').focus();

            // Start spawn timer
            const diffConfig = difficulties[gameState.difficulty];
            gameState.spawnTimer = setInterval(() => {
                if (gameState.isPlaying && creatures.length < 6 + gameState.level) {
                    spawnCreature();
                }
            }, diffConfig.spawnRate - gameState.level * 100);

            // Start game loop
            animate();
        }

        function gameOver() {
            gameState.isPlaying = false;
            clearInterval(gameState.spawnTimer);

            // Check highscore
            if (gameState.score > gameState.highscore) {
                gameState.highscore = gameState.score;
                localStorage.setItem('mathGame3DHighscore', gameState.score);
                document.getElementById('newHighscoreMessage').style.display = 'block';
            }

            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('finalLevel').textContent = gameState.level;
            document.getElementById('displayHighscore').textContent = gameState.highscore;
            document.getElementById('gameOverScreen').style.display = 'flex';
        }

        function animate() {
            if (!gameState.isPlaying) return;

            requestAnimationFrame(animate);

            // Update creatures
            for (let i = creatures.length - 1; i >= 0; i--) {
                const creature = creatures[i];
                const reachedPlayer = creature.update();

                if (reachedPlayer) {
                    creature.destroy();
                    creatures.splice(i, 1);
                    loseLife();
                    updateCreatureCount();
                }
            }

            // Update particles
            updateParticles();

            // Flicker torch lights
            pointLights.forEach((light, i) => {
                light.intensity = 0.6 + Math.sin(Date.now() * 0.01 + i) * 0.2;
            });

            renderer.render(scene, camera);
        }

        // Event Listeners
        document.querySelectorAll('.difficulty-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                gameState.difficulty = btn.dataset.difficulty;
            });
        });

        document.getElementById('submitButton').addEventListener('click', handleSubmit);

        document.getElementById('answerInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleSubmit();
            }
        });

        // Initial highscore display
        document.getElementById('highscore').textContent = gameState.highscore;
    </script>
</body>
</html>
